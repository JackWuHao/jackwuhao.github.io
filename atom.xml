<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaocaoaixuexi.club</id>
    <title>吴浩的个人博客</title>
    <updated>2019-11-10T02:21:58.320Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaocaoaixuexi.club"/>
    <link rel="self" href="https://xiaocaoaixuexi.club/atom.xml"/>
    <subtitle>每一天都是学习的一天</subtitle>
    <logo>https://xiaocaoaixuexi.club/images/avatar.png</logo>
    <icon>https://xiaocaoaixuexi.club/favicon.ico</icon>
    <rights>All rights reserved 2019, 吴浩的个人博客</rights>
    <entry>
        <title type="html"><![CDATA[持续学习 每日一更 springboot]]></title>
        <id>https://xiaocaoaixuexi.club/post/chi-xu-xue-xi-mei-ri-yi-geng-springboot</id>
        <link href="https://xiaocaoaixuexi.club/post/chi-xu-xue-xi-mei-ri-yi-geng-springboot">
        </link>
        <updated>2019-11-05T11:57:49.000Z</updated>
        <content type="html"><![CDATA[<p>ps:学习java是真的费劲,估计最少的一个月才能入门，还是我大python 爽呀学习成本基本没有搞起来贼快
想念django的第一天
<a href="https://github.com/JackWuHao/SpringBootTest.git">下载地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Springboot  maven及spring 介绍]]></title>
        <id>https://xiaocaoaixuexi.club/post/springboot-maven-ji-spring-jie-shao</id>
        <link href="https://xiaocaoaixuexi.club/post/springboot-maven-ji-spring-jie-shao">
        </link>
        <updated>2019-11-05T03:45:33.000Z</updated>
        <content type="html"><![CDATA[<p>关于maven 的介绍： apache maven 是一个软件项目管理，基于对象模型（POM）的概念，用来管理项目的依赖，编译，文档等信息</p>
<p>spring项目的搭建</p>
<ol>
<li>新建Maven 项目 ，单击file-&gt;new -&gt;Project -&gt;maven</li>
<li>输入maven项目坐标</li>
<li>选择存库路径</li>
<li>修改pom.xml 的配置文件<br>
下面给一个配置实例</li>
</ol>
<pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.wuhao.cn&lt;/groupId&gt;
    &lt;artifactId&gt;hight_spring4&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;properties&gt;
        &lt;java.version&gt; 1.7 &lt;/java.version&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;defaultGoal&gt;compile&lt;/defaultGoal&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
            &lt;groupId&gt; org.apache.maven.plugins &lt;/groupId&gt;
            &lt;artifactId&gt; maven-compiler-plugin &lt;/artifactId&gt;
            &lt;version&gt; 2.3.2 &lt;/version&gt;
            &lt;configuration&gt;
                &lt;source&gt; $(java.version) &lt;/source&gt;
                &lt;target&gt; $(java.version) &lt;/target&gt;
            &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;


&lt;/project&gt;
</code></pre>
<p>IoC: 实际上是指 Spring 框架提供的 IoC 容器实现（IoC Container ) ，使用IOC 容器的一个典型代码片段：</p>
<pre><code>public class App {
    public static void main(String[] args) {
        ApplicationContext context = new FileSystemXmlApplication-Context(&quot;...&quot;);
        // ...
        MockService service = context.getBean(MockService.class);
        service.doSomething();
    }
}
</code></pre>
<p>IoC有两种方式，一种是DI , 一种是DL;前者是当前软件实体被动接受其依赖的其他组件被 IoC 容器注入，而后者则是当前软件实体主动去某个服务注册地查找其依赖的那些服务<br>
Spring IoC 容器的依赖注入工作可以分为两个阶段：</p>
<h1 id="1-收集和注册">1 收集和注册</h1>
<p>第一个阶段可以认为是构建和收集 bean 定义的阶段，在这个阶段中，我们可以通过 XML 或者 Java 代码的方式定义一些 bean，然后通过手动组装或者让容器基于某些机制自动扫描的形式，将这些 bean 定义收集到 IoC 容器中。<br>
声明 Bean的注解：</p>
<ul>
<li>@Compoent 组件</li>
<li>@Service  在业务层使用（service）</li>
<li>@Controller 在展现层（MVC-&gt;SpringMVC）中使用<br>
注入Bean 的注解</li>
<li>@Autowired: Spring提供的注解</li>
<li>@Inject: JSR-330提供的注解</li>
<li>@Resource: JSR-250提供的注解
他们可以注解在set方法上或者属性上 ，优点:代码少，层次清晰</li>
</ul>
<h2 id="示例">示例：</h2>
<p>编写功能类的示例：</p>
<pre><code>package com.wuho.cn;
import  org.springframework.stereotype.Service;
@Service  //声明ben
public class FunctionService {

    public String sayHello(String word) {
        return &quot;Hello&quot; + &quot;world&quot; + &quot;!&quot;;
    }

}
</code></pre>
<p>使用功能类的示例</p>
<pre><code>package com.wuho.cn;
import  org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UseFunctionService {
    @Autowired  //使用bean
    FunctionService functionService;
    public String sayHello(String world) {
        return functionService.sayHello(world);
    }
}

</code></pre>
<h1 id="2-分析和组装">2 分析和组装</h1>
<p>当第一阶段工作完成后，我们可以先暂且认为 IoC 容器中充斥着一个个独立的 bean，它们之间没有任何关系。
IoC 容器在第二阶段要干的事情就是分析这些已经在 IoC 容器之中的 bean，然后根据它们之间的依赖关系先后组装它们
Spring 的 XML 配置文件是一种配置（Configuration），但本质上，这些配置文件更应该是一种代码形式，XML 在这里其实可以看作一种 DSL(domain specific language:即领域专用语言)，它用来表述的是 bean 与 bean 之间的依赖绑定关系，如果没有 IoC 容器就要自己写代码新建（new）对象并配置（set）依赖。</p>
<p>配置类</p>
<pre><code>package com.wuho.cn;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration  //配置
@ComponentScan(&quot;com.wuho.cn&quot;) //自动扫描包名下的所有@Service @Compoent  @Repository  @Controller 的类，并注册为Bean

public class DIConfig {
}

</code></pre>
<p>运行</p>
<pre><code>package com.wuho.cn;

import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class Main {

    public static void main(String[] args) {
        //声明 使用 AnnotationConfigApplicationContext 作为Spring的容器，接受输入一个配置类作为参数
        AnnotationConfigApplicationContext content = new AnnotationConfigApplicationContext(DIConfig.class);
        //获取声明的UseFunctionService 的bean
        UseFunctionService  useFunctionService =  content.getBean(UseFunctionService.class);
        System.out.println(useFunctionService.sayHello(&quot;di&quot;));
        content.close();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Springboot 学习记录 搭建环境]]></title>
        <id>https://xiaocaoaixuexi.club/post/springboot-xue-xi-ji-lu-da-jian-huan-jing</id>
        <link href="https://xiaocaoaixuexi.club/post/springboot-xue-xi-ji-lu-da-jian-huan-jing">
        </link>
        <updated>2019-11-05T03:34:57.000Z</updated>
        <content type="html"><![CDATA[<p>推荐使用idea  ,  <a href="https://www.jetbrains.com/idea/">下载地址</a>  ,能支持正版的支持正版 ，破解方案之前pycharm的破解过程一样都是jetbrains家的东西 <a href="https://jackwuhao.github.io/post/pycharm-zui-xin-po-jie-fang-an/">Pycharm 最新破解方案</a>   注意改下配置文件的路径</p>
<pre><code>-javaagent:/Applications/IntelliJ IDEA.app/Contents/bin/jetbrains-agent.jar

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[听说flutter 支持web了，之前丢弃的flutter 重新捡起来]]></title>
        <id>https://xiaocaoaixuexi.club/post/ting-shuo-flutter-zhi-chi-web-liao-zhi-qian-diu-qi-de-flutter-chong-xin-jian-qi-lai</id>
        <link href="https://xiaocaoaixuexi.club/post/ting-shuo-flutter-zhi-chi-web-liao-zhi-qian-diu-qi-de-flutter-chong-xin-jian-qi-lai">
        </link>
        <updated>2019-10-30T13:34:09.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/JackWuHao/flutterTest.git">下载地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[意外发现了很有趣的一种无限轮播写法(有缺陷)]]></title>
        <id>https://xiaocaoaixuexi.club/post/yi-wai-fa-xian-liao-hen-you-qu-de-yi-chong-wu-xian-lun-bo-xie-fa-you-que-xian</id>
        <link href="https://xiaocaoaixuexi.club/post/yi-wai-fa-xian-liao-hen-you-qu-de-yi-chong-wu-xian-lun-bo-xie-fa-you-que-xian">
        </link>
        <updated>2019-10-29T12:19:38.000Z</updated>
        <content type="html"><![CDATA[<p>正常我们做轮播图的做法都是通过scrollView,uipageContol,uiimageView通过301231的原理，在集左，极右的情况下变换偏移量，造成无线轮播的假象（collection,tabview,原理类似，省去了复用的步骤）这些常规操作</p>
<p><strong>重点来了</strong></p>
<p>懒得写了直接上链接<a href="https://www.jianshu.com/p/9538fa9f9321">仅仅一个UIImageView就可以实现无限轮播图效果</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift  5.1  API测试 ]]></title>
        <id>https://xiaocaoaixuexi.club/post/swift-51-api-ce-shi</id>
        <link href="https://xiaocaoaixuexi.club/post/swift-51-api-ce-shi">
        </link>
        <updated>2019-10-25T08:43:10.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/JackWuHao/Swift5.1APITest.git">下载地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[好文章记录一下（面向对象与面向过程的本质区别）]]></title>
        <id>https://xiaocaoaixuexi.club/post/hao-wen-zhang-ji-lu-yi-xia</id>
        <link href="https://xiaocaoaixuexi.club/post/hao-wen-zhang-ji-lu-yi-xia">
        </link>
        <updated>2019-10-19T09:25:48.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/jerry11112/article/details/79027834">面向对象与面向过程的本质区别</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[django 如何接收post请求]]></title>
        <id>https://xiaocaoaixuexi.club/post/django-ru-he-jie-shou-post-qing-qiu</id>
        <link href="https://xiaocaoaixuexi.club/post/django-ru-he-jie-shou-post-qing-qiu">
        </link>
        <updated>2019-10-17T09:40:07.000Z</updated>
        <content type="html"><![CDATA[<pre><code># URL = &quot;http://127.0.0.1:8000/test/?test=3&quot;
from django.views.decorators.csrf import csrf_exempt
@csrf_exempt
def test(request):
     if request.method == 'GET':
        a = request.GET.get('test')
    else:
        a = request.POST.get('test')
      print(a)  

return JsonResponse({&quot;data&quot;:&quot;成功&quot;}) 


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[django  后台如何设置header 和cookie]]></title>
        <id>https://xiaocaoaixuexi.club/post/django-hou-tai-ru-he-she-zhi-heads-he-cookie</id>
        <link href="https://xiaocaoaixuexi.club/post/django-hou-tai-ru-he-she-zhi-heads-he-cookie">
        </link>
        <updated>2019-10-17T09:25:07.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>使用JsonResponse直接返回(推荐)</li>
</ol>
<pre><code>from django.http import HttpResponse,JsonResponse  
def test(request):
   b = {&quot;data&quot;:&quot;成功&quot;} 
return JsonResponse(b)

</code></pre>
<ol start="2">
<li>使用 HttpResponse返回</li>
</ol>
<pre><code>from django.http import HttpResponse,JsonResponse  
def test(request):
   b = {&quot;data&quot;:&quot;成功&quot;} 
return JsonResponse(json.dumps(b))
</code></pre>
<ol start="3">
<li>返回时设置cookie 和header</li>
</ol>
<pre><code>from django.http import HttpResponse,JsonResponse  
def test(request):
    response = HttpResponse()
    data = {&quot;data&quot;:&quot;成功&quot;}
    response.content = json.dumps(data)
    response.status_code = 200
    response['name'] = 'xuanli' #设置header
    response.set_cookie(&quot;TOKEN&quot;, &quot;token&quot;) #设置cookie
    return response
</code></pre>
<p>4.测试代码及结果</p>
<pre><code>  [MBProgressHUD showHUDAddedTo:self.view animated:YES];
        [WHRequestmanager  requetWithMethondType:WHRequestMenthonTypeGET requestAPICode:@&quot;/test&quot; requestDic:@{} headerDic:@{} sucessBlock:^(id  _Nonnull responseObject) {
            [MBProgressHUD hideHUDForView:self.view animated:YES];
            NSHTTPCookieStorage  *cookies = [NSHTTPCookieStorage sharedHTTPCookieStorage];
            NSLog(@&quot;%@&quot;,cookies);
        } failureBlock:^(NSError * _Nonnull error) {
            [MBProgressHUD hideHUDForView:self.view animated:YES];
        }];
</code></pre>
<p><img src="https://xiaocaoaixuexi.club/post-images/1571304929571.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[django 如何使用token 做身份验证]]></title>
        <id>https://xiaocaoaixuexi.club/post/django-ru-he-she-zhi-token</id>
        <link href="https://xiaocaoaixuexi.club/post/django-ru-he-she-zhi-token">
        </link>
        <updated>2019-10-17T09:03:35.000Z</updated>
        <content type="html"><![CDATA[<p>最近在搭建一个后台框架引入了token 来身份验证</p>
<ol>
<li>安装 django-redis</li>
</ol>
<pre><code>pip install django-redis
</code></pre>
<ol start="2">
<li>首先在django.setting里面设置</li>
</ol>
<pre><code>CACHES = {
    &quot;default&quot;: {
        &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;,
        &quot;LOCATION&quot;: &quot;redis://127.0.0.1:6379&quot;,
        &quot;OPTIONS&quot;: {
            &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;,
        }
    }
}
</code></pre>
<ol start="3">
<li>如果没有安装redis服务端此时会报错 ,安装<a href="https://www.cnblogs.com/kermitjam/p/11193466.html">安装redis</a>   再运行一遍</li>
<li>在vies.py  添加如下代码</li>
</ol>
<pre><code>import time
from django.core import signing
import hashlib
from django.core.cache import cache

HEADER = {'typ': 'JWP', 'alg': 'default'}
KEY = 'WH_WUHAO'
SALT = 'www.xiaocao'
TIME_OUT = 30 * 60  # 30min

def encrypt(obj):
    &quot;&quot;&quot;加密&quot;&quot;&quot;
    value = signing.dumps(obj, key=KEY, salt=SALT)
    value = signing.b64_encode(value.encode()).decode()
    return value

def decrypt(src):
    &quot;&quot;&quot;解密&quot;&quot;&quot;
    src = signing.b64_decode(src.encode()).decode()
    raw = signing.loads(src, key=KEY, salt=SALT)
    print(type(raw))
    return raw


def create_token(username):
    &quot;&quot;&quot;生成token信息&quot;&quot;&quot;
    # 1. 加密头信息
    header = encrypt(HEADER)
    # 2. 构造Payload
    payload = {&quot;username&quot;: username, &quot;iat&quot;: time.time()}
    payload = encrypt(payload)
    # 3. 生成签名
    md5 = hashlib.md5()
    md5.update((&quot;%s.%s&quot; % (header, payload)).encode())
    signature = md5.hexdigest()
    token = &quot;%s.%s.%s&quot; % (header, payload, signature)
    cache.set(username, token, TIME_OUT)
    return token

def get_payload(token):
    payload = str(token).split('.')[1]
    payload = decrypt(payload)
    return payload

# 通过token获取用户名
def get_username(token):
    payload = get_payload(token)
    return payload['username']
    pass

#检查token
def check_token(token):
    username = get_username(token)
    last_token = cache.get(username)
    if last_token:
        return last_token == token
    return False
</code></pre>
<blockquote>
<p><a href="https://blog.csdn.net/cfy137000/article/details/79189252">django如何使用token</a></p>
</blockquote>
]]></content>
    </entry>
</feed>